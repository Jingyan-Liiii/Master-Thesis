v010:
- read lpb-file only
- constraints are given the block, they belong to
- create constraints in original and master simultaniously
- working scip represents the master problem, original and pricer-MIPs as sub-SCIPs

v020:
- read lpb and blk file
- lpb equialent to lp files; blk defines, which variable belongs to which block
- working scip represents the master problem, original and pricer-MIPs as sub-SCIPs
- presolve original problem, create constraints and vars in master and pricing problems 
  after that and use the presolving information
- solve root-node of original program
- tried to separate by calling SCIPseparateSol() on the original program 
  (problem here: SCIPisStopped() returns TRUE, has to be changed somehow...)

v030:
- working scip represents the original problem
- the master problem is represented by a relaxator, which replaces the lp-solving
- separation is done by a separator included in the master scip, which calls the 
  SCIPseparateSol() method in the original scip
- branching is done simultaneously in the master and in the original scip
- variables in the master are still extreme points (and rays, but functionality currently not implemented)
  of conv(X) -> convexification approach
- many identical pricing problems -> fat too much effort for pricing, especially farkas pricing!

v040:
- read in problem is standard format (e.g., .lp-file, .mps-file) and corresponding blk-file
- in blk-file, we can indicate constraints that are forced to be in the master problem;
  all other constraints are added to a block, if they only contain variables of this block
- added possibility to use discretization approach, variables in the master then represent integer points in X,
  integrality in the master is demanded
- identification of identical blocks -> break symmetrie in the master
- 2 constraint handler assure that nodes in the master scip are linked to nodes in the original scip and vice versa
- branching rules are implemented as branching rules in the master that have to define the additional 
  callbacks specified in "type_branchgcg.h"
- 2 branching rules implemented so far: 
  branching on original variables (not possible if variable belongs to a block that has similar blocks in the problem),
  using pseudocost values to choose the variable to branch on
  ryan-foster type of branching for identical blocks with set partitioning structure
- own display plugin showing the number of LP iterations, of cosntraints, variables and cuts in the master
