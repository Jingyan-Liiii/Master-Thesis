/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                                             */
/*                  This file is part of the program                               */
/*          GCG --- Generic Column Generation                                   */
/*                  a Dantzig-Wolfe decomposition based extension         */
/*                  of the branch-cut-and-price framework                     */
/*         SCIP --- Solving Constraint Integer Programs                    */
/*                                                                                             */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file   heur_violrowgreedycolsel.c
 * @ingroup PRIMALHEURISTICS
 * @brief  greedy column selection primal heuristic basic A* with h=nviolrows
 * @author Marcel Schmickerath
 */

/*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/

/* toggle debug mode */
#define SCIP_DEBUG

#include <assert.h>

#include "heur_violrowgreedycolsel.h"
#include "pricer_gcg.h"
#include "pub_gcgvar.h"
#include "relax_gcg.h"


#define HEUR_NAME             "violrowgreedycolsel"
#define HEUR_DESC             "greedy column selection heuristic basic A* with h=nviolrow index is best out of three"
#define HEUR_DISPCHAR         'e'
#define HEUR_PRIORITY         0
#define HEUR_FREQ             2
#define HEUR_FREQOFS          0
#define HEUR_MAXDEPTH         -1
/* TODO: should heuristic be called during the pricing loop or only after solving a node relaxation? */
#define HEUR_TIMING           SCIP_HEURTIMING_DURINGLPLOOP | SCIP_HEURTIMING_DURINGPRICINGLOOP
#define HEUR_USESSUBSCIP      FALSE

#define DEFAULT_MINCOLUMNS    200             /**< minimum number of columns to regard in the master problem */

#define DEFAULT_MAXSEARCHWIDTH    3             /**< maximal number of nodes generated at expanding one node */


/*
 * Data structures
 */

/** primal heuristic data */
struct SCIP_HeurData
{
   int                  mincolumns;           /**< minimum number of columns to regard in the master problem */

   int                  maxsearchwidth;           /**< maximal number of nodes generated at expanding one node */

   int                  lastncols;            /**< number of columns in the last call of the heuristic       */
};


/** Node of the searchtree */
struct SCIP_SearchNode
{
      int              g;           /**< costs to reach this Node (here depth)*/

      int              h;            /**< value to sort in priorityqueue, here: nviolrows*/

      int              lbnnodes;            /**< number of columns which should at least be added to get a primal solution   */

      int*              selected;          /**< which mastervars were already choosed and number */

      SCIP_Real*              activity;    /**< activity for this Node e.t. for the current choice of mastervars */

      int*              blocknr;

      SCIP_VAR*         mastervar;

};


/*
 * Local methods
 */


/* How would the number of violated rows change if mastervar were increased?  */
static
int getViolationChange(
      SCIP*                   scip,
      SCIP_Real*              activities,
      SCIP_VAR*               mastervar
      )
{
   SCIP_COL* col;
   SCIP_ROW** colrows;
   SCIP_Real* colvals;
   int ncolrows;
   int violchange;

   int r;

   /* get the rows in which the master variable appears (only these must be regarded) */
   col = SCIPvarGetCol(mastervar);
   colrows = SCIPcolGetRows(col);
   colvals = SCIPcolGetVals(col);
   ncolrows = SCIPcolGetNLPNonz(col);
   assert(ncolrows == 0 || (colrows != NULL && colvals != NULL));

   violchange = 0;
   for( r = 0; r < ncolrows; r++ )
   {
      SCIP_ROW* row;
      int rowpos;

      row = colrows[r];
      rowpos = SCIProwGetLPPos(row);
      assert(-1 <= rowpos);

      if( rowpos >= 0 && !SCIProwIsLocal(row) )
      {
         SCIP_Real oldactivity;
