# Branch-and-price without a single line of code # {#u1}

> In this first use case, we develop a branch-and-price algorithm for
> a combinatorial optimization problem without writing a single line
> of code. We only need to be able formulate our problem as a (mixed)
> integer program. For that we will use the \ZIMPL modeling language.


#### The Problem ####

We consider a variant of a classic NP-hard combinatorial optimization
problem. Given an undirected graph \f$G=(V,E)\f$, a *dominating set*
\f$S\subseteq V\f$ is a subset of the vertices, such that every vertex
\f$i \in V\f$ is in \f$S\f$ or adjacent to a vertex in \f$S\f$. We say
that every vertex not in \f$S\f$ is *dominated* by a vertex in
\f$S\f$. For the *capacitated dominating set problem* we are
additionally given vertex weights \f$u:V\rightarrow
\mathbb{Z}_+\f$. Loosely speaking, every vertex \f$i \in V\f$ can
dominate at most \f$u(i)\f$ many other vertices. More formally, a
subset \f$S\subseteq V\f$ is a capacitated dominating set if and only
if there exists a mapping \f$f:V\setminus S\rightarrow S\f$ such that
the number of vertices mapped under \f$f\f$ to \f$i\in S\f$ is no more
than \f$u(i)\f$.



The following example graph is taken from \cite gcg:PotluriSingh:2012. 
All vertices have capacity 2, and a minimum capacitated dominated set
consists of e.g., \f$S=\{2,6,7,8,12\}\f$. An arc \f$(i,j)\f$ is
interpreted as ''\f$i\f$ is dominated by \f$j\f$,'' representing a 
possible mapping \f$f\f$.

\image html cds-graph-potluri.png "example graph where all vertices have capacity 2" width=50%



#### A ''Textbook'' Binary Program ####

The following intuitive model was presented in \cite gcg:Li-etal:2018
(actually, we corrected it a bit). We use variables
\f$x_i\in\{0,1\}\f$, \f$i\in V\f$, to represent whether \f$i\in S\f$,
i.e., it is in the dominating set or not. The mapping \f$f\f$ is
represented by variables \f$y_{ij}\in\{0,1\}\f$, \f$\{i,j\}\in E\f$,
that we interpret as \f$y_{ij}=1 \iff f(j)=i\f$, that is, when \f$j\f$
is dominated by \f$i\f$. Define \f$N(i):=\{j\in V : \{i,j\}\in E\}\f$
as the set of *neighbors* of \f$i\in V\f$.


\f{align}{
  & \text{min}
  & & \sum_{i\in V}x_i \\
  & \text{s.t.} & & \sum_{j\in N(i)} y_{ji} \geq 1 - x_i & i\in V \\
  & & & \sum_{j\in N(i)} y_{ij} \leq u_i x_i & i\in V \\
  & & & x_i\in\{0,1\} & i\in V \\
  & & & y_{ij}\in\{0,1\} & \{i,j\}\in E 
  \f}

The objective function minimizes \f$|S|\f$. Every vertex is dominated
by a neighbor or is itself in \f$S\f$; and no vertex can dominate more
vertices than given by its capacity (the capacity is available only if
the vertex is in \f$S\f$). Thus, the capacity constraints also link
the \f$x\f$ and \f$y\f$ variables.

A \ZIMPL model file ([download](potluri+singh.zpl)) for the above instance is as follows: 

```
# vertices 
set V := {1 .. 14};
# (undirected) edges
set E := {<1,2>, <2,3>, <2,4>, <4,6>, <3,8>, <7,8>, <5,6>, <6,9>, <6,10>, <6,11>, <7,11>, <7,12>, <7,13>, <7,14>, <10,12>, <11,12>};
# (directed) arcs, produced from (undirected) edges
set A := E union {<j,i> in V*V with <i,j> in E};

# uniform capacity of 2 for each vertex
param cap[<v> in V] := 2;

# neighbors of v
defset N(v) := {<i> in V with <v,i> in A};


# is v selected in the dominating set?
var x[V] binary;

# for <i,j> in A: is j dominated by i?
var y[A] binary;


minimize cost: sum<v> in V: x[v];

# every vertex v must be dominated by some vertex i (unless v is selected)
subto dominate:
	forall <v> in V: sum<i> in N(v): y[i,v] >= 1 - x[v];

# the domination capacity of each vertex must be respected
subto capacity:
	forall <v> in V: sum<i> in N(v): y[v,i] <= x[v]*cap[v];

```    
    


\n Of course, you can use any modeling language you like, or generate
your model (typically in `.lp` or `.mps` format) using a script. A
bonus from using \ZIMPL is that \GCG can directly read the model file
(when you compiled it with ``ZIMPL=true``). So, start \GCG and


```
GCG> read potluri+singh.zpl 

...

original problem has 46 variables (46 bin, 0 int, 0 impl, 0 cont) and 60 constraints
GCG> 

```

\n If \GCG complains about a missing reader (because you compiled it
with ``ZIMPL=false``), alternatively run \ZIMPL on the ``.zpl`` file
to generate an ``.lp`` or ``.mps``, and read this into \GCG. Then start
the optimization.


```
GCG> optimize

...

A Dantzig-Wolfe reformulation is applied to solve the original problem.

  time | node  | left  |SLP iter|MLP iter|LP it/n| mem |mdpt |ovars|mvars|ocons|mcons|mcuts|  dualbound   | primalbound  |  deg   |  gap   
t  0.0s|     1 |     0 |      0 |      0 |     - | 905k|   0 |  17 |   0 |   9 |   0 |   0 | 3.000000e+00 | 1.200000e+01 |   --   | 300.00%
i  0.0s|     1 |     0 |      0 |      0 |     - | 915k|   0 |  17 |   0 |   9 |   0 |   0 | 3.000000e+00 | 8.000000e+00 |   --   | 166.67%
*  0.0s|     1 |     0 |      0 |      0 |     - | 915k|   0 |  17 |   0 |   9 |   0 |   0 | 5.000000e+00 | 5.000000e+00 |   --   |   0.00%
   0.0s|     1 |     0 |      0 |      0 |     - | 915k|   0 |  17 |   0 |   9 |   0 |   0 | 5.000000e+00 | 5.000000e+00 |   --   |   0.00%

SCIP Status        : problem is solved [optimal solution found]
Solving Time (sec) : 0.01
Solving Nodes      : 1
Primal Bound       : +5.00000000000000e+00 (4 solutions)
Dual Bound         : +5.00000000000000e+00
Gap                : 0.00 %

GCG> 
```

\n When we look at the optimal solution we find \f$S=\{2,6,7,8,12\}\f$ as in the figure above.
 

```
GCG> display solution

objective value:                                    5
x#2                                                 1   (obj:1)
x#6                                                 1   (obj:1)
x#7                                                 1   (obj:1)
x#8                                                 1   (obj:1)
x#12                                                1   (obj:1)
y#2#4                                               1   (obj:0)
y#2#1                                               1   (obj:0)
y#7#13                                              1   (obj:0)
y#7#14                                              1   (obj:0)
y#6#9                                               1   (obj:0)
y#6#5                                               1   (obj:0)
y#8#3                                               1   (obj:0)
y#8#7                                               1   (obj:0)
y#12#11                                             1   (obj:0)
y#12#10                                             1   (obj:0)

GCG> 
```

\n This instance is too easy, so not much happened in \GCG, but had we
tried a larger instance, we would have witnessed a full-fledged
branch-and-price algorimth at work to solve the capacitated dominating
set problem.

> We could just stop here because our problem is solved. For those interested, we
> move on to answer the following questions:
>
> 1. What exactly happened? (Dantzig-Wolfe reformulation and alternative model)
> 
> 2. Is it worth it? (is this faster than \SCIP?)



#### A Binary Program Based on Subsets of Vertices ####

In the compact model, the \f$y\f$-variables represent a subset \f$T :=
\{j \in V : y_{ij}=1\} \cup \{i\} \subseteq N(i) \cup \{i\}\f$ for
each vertex \f$i\in V\f$. The color classes in the figure above
exactly correspond to such subsets.  The important observation is that
an (optimal) solution to the capacitated dominated set problem is a
partition of the vertices into (a minimum number of) such subsets, one
for each vertex in \f$S\f$.

We base an alternative model on this observation.  Introduce a binary
variable \f$\lambda^i_T\in\{0,1\}\f$ for *each possible* subset
\f$T\subseteq N(i) \cup \{i\}\f$ of neighbors of \f$i\in V\f$ (and
\f$i\f$ itself), where we require \f$i\in T\f$ and \f$|T|\leq
u_i+1\f$.  Denote the collection of all feasible vertex subsets for
\f$i\in V\f$ by \f$\cal T_i\f$.





# work in progress below this point #


\f{align}{
  & \text{min}
  & & \sum_{i\in V}\sum_{T \in \cal T_i} \lambda^i_T \\
  & \text{s.t.} & & \sum_{j\in N(i)} y_{ji} \geq 1 - x_i & i\in V \\
  & & & \sum_{j\in N(i)} y_{ij} \leq u_i x_i & i\in V \\
  & & & y_{ij} \leq x_i & i\not=j\in V \\
  & & & x_i\in\{0,1\} & i\in V \\
  & & & y_{ij}\in\{0,1\} & \{i,j\}\in E 
  \f}




Actually, this alternative model results from a Dantzig-Wolfe reformulation of the compact model.



\GCG by default does not make use of the row and column names, but it can be told to do so:

```
GCG> set detection consclassifier consnamenonumbers origenabled TRUE
```


\image html potluri+singh-dec-14.png "decomposition with 14 blocks" width=70%

\image html potluri+singh-dec-14-v.png "decomposition with 14 blocks and linking variables" width=70%




If you are interested, Potluri and Singh \cite gcg:PotluriSingh:2012 made all their instances [publicly available for download](http://scis.uohyd.ac.in/~apcs/capmds/), together with the `C` code for their heuristics. We provide \ZIMPL model files that read their input, for [uniform](CDS_uni.zpl) and [variable](todo) capacities.

The authors .. provide the data they used in their publication [here] and a general \ZIMPL that can read their instances as input is [here (local ressource)].








was it worth it?

compare \SCIP on the original model, \GCG with our selected decomposition, and \GCG automatic detection. performance profiles.