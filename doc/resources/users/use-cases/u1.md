# Branch-and-price without a single line of code # {#u1}

> In this first use case, we develop a branch-and-price algorithm for
> a combinatorial optimization problem without writing a single line
> of code. We only need to be able formulate our problem as a (mixed)
> integer program. For that we will use the \ZIMPL modeling language.


#### The Problem ####

We consider a variant of a classic NP-hard combinatorial optimization
problem. Given an undirected graph \f$G=(V,E)\f$, a *dominating set*
\f$S\subseteq V\f$ is a subset of the vertices, such that every vertex
\f$i \in V\f$ is in \f$S\f$ or adjacent to a vertex in \f$S\f$. We say
that every vertex not in \f$S\f$ is *dominated* by a vertex in
\f$S\f$. For the *capacitated dominating set problem* we are
additionally given vertex weights \f$u:V\rightarrow
\mathbb{Z}_+\f$. Loosely speaking, every vertex \f$i \in V\f$ can
dominate at most \f$u(i)\f$ many other vertices. More formally, a
subset \f$S\subseteq V\f$ is a capacitated dominating set if and only
if there exists a mapping \f$f:V\setminus S\rightarrow S\f$ such that
the number of vertices mapped under \f$f\f$ to \f$i\in S\f$ is no more
than \f$u(i)\f$.



The following example graph is taken from \cite gcg:PotluriSingh:2012. 
All vertices have capacity 2, and a minimum capacitated dominated set
consists of e.g., \f$S=\{2,6,7,8,12\}\f$. An arc \f$(i,j)\f$ is
interpreted as ''\f$i\f$ is dominated by \f$j\f$,'' representing a 
possible mapping \f$f\f$.

\image html cds-graph-potluri.png "example graph where all vertices have capacity 2" width=50%



#### A Binary Program ####

The following intuitive model was presented in \cite gcg:Li-etal:2018
(actually, we corrected it a bit). We use variables
\f$x_i\in\{0,1\}\f$, \f$i\in V\f$, to represent whether \f$i\in S\f$,
i.e., it is in the dominating set or not. The mapping \f$f\f$ is
represented by variables \f$y_{ij}\in\{0,1\}\f$, \f$\{i,j\}\in E\f$,
that we interpret as \f$y_{ij}=1 \iff f(j)=i\f$, that is, when \f$j\f$
is dominated by \f$i\f$. Define \f$N(i)=\{j\in V : \{i,j\}\in E\}\f$
as the set of *neighbors* of \f$i\in V\f$.


\f{align}{
  & \text{min}
  & & \sum_{i\in V}x_i \\
  & \text{s.t.} & & \sum_{j\in N(i)} y_{ji} \geq 1 - x_i & i\in V \\
  & & & \sum_{j\in N(i)} y_{ij} \leq u_i x_i & i\in V \\
  & & & y_{ij} \leq x_i & i\not=j\in V \\
  & & & x_i\in\{0,1\} & i\in V \\
  & & & y_{ij}\in\{0,1\} & \{i,j\}\in E 
  \f}

The objective function minimizes \f$|S|\f$. Every vertex is dominated
by a neighbor or is itself in \f$S\f$; and no vertex can dominate more
vertices than given by its capacity (the capacity is available only if
the vertex is in \f$S\f$). The linking constraints ensure that a
vertex can dominate another only when it is selected in \f$S\f$.

A \ZIMPL model file ([download](potluri+singh.zpl)) for the above instance is as follows: 

```
# vertices 
set V := {1 .. 14};
# (undirected) edges
set E := {<1,2>, <2,3>, <2,4>, <4,6>, <3,8>, <7,8>, <5,6>, <6,9>, <6,10>, <6,11>, <7,11>, <7,12>, <7,13>, <7,14>, <10,12>, <11,12>};
# (directed) arcs, produced from (undirected) edges
set A := E union {<j,i> in V*V with <i,j> in E};

# uniform capacity of 2 for each vertex
param cap[<v> in V] := 2;

# neighbors of v
defset N(v) := {<i> in V with <v,i> in A};


# is v selected in the dominating set?
var x[V] binary;

# for <i,j> in A: is j dominated by i?
var y[A] binary;


minimize cost: sum<v> in V: x[v];

# every vertex v must be dominated by some vertex i (unless v is selected)
subto dominate:
	forall <v> in V: sum<i> in N(v): y[i,v] >= 1 - x[v];

# the domination capacity of each vertex must be respected
subto capacity:
	forall <v> in V: sum<i> in N(v): y[v,i] <= x[v]*cap[v];

# link the y and the x variables
subto link:
	forall <v> in V: forall <i> in N(v): y[v,i] <= x[v];

```    
    

Of course, you can use any modeling language you like, or generate your model (typically in `*.lp` or `*.mps` format) using a script. A bonus from using \ZIMPL is that \GCG can directly read the model file.



If you are interested, Potluri and Singh \cite gcg:PotluriSingh:2012 made all their instances [publicly available for download](http://scis.uohyd.ac.in/~apcs/capmds/), together with the `C` code for their heuristics. We provide \ZIMPL model files that read their input, for [uniform](CDS_uni.zpl) and [variable](todo) capacities.

The authors .. provide the data they used in their publication [here] and a general \ZIMPL that can read their instances as input is [here (local ressource)].




**Optimization in \GCG**




was it worth it?

compare \SCIP on the original model, \GCG with our selected decomposition, and \GCG automatic detection. performance profiles.